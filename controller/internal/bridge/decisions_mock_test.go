package bridge

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"

	"gasboat/controller/internal/beadsapi"
)

// mockDaemon implements BeadClient for testing.
type mockDaemon struct {
	mu       sync.Mutex
	beads    map[string]*beadsapi.BeadDetail
	closed   []closeCall
	getCalls int
}

type closeCall struct {
	BeadID string
	Fields map[string]string
}

func newMockDaemon() *mockDaemon {
	return &mockDaemon{
		beads: make(map[string]*beadsapi.BeadDetail),
	}
}

func (m *mockDaemon) GetBead(_ context.Context, beadID string) (*beadsapi.BeadDetail, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.getCalls++
	if b, ok := m.beads[beadID]; ok {
		return b, nil
	}
	return &beadsapi.BeadDetail{ID: beadID}, nil
}

func (m *mockDaemon) FindAgentBead(_ context.Context, agentName string) (*beadsapi.BeadDetail, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.getCalls++
	if b, ok := m.beads[agentName]; ok {
		return b, nil
	}
	return nil, fmt.Errorf("agent bead not found for agent %q", agentName)
}

func (m *mockDaemon) CloseBead(_ context.Context, beadID string, fields map[string]string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.closed = append(m.closed, closeCall{BeadID: beadID, Fields: fields})
	return nil
}

func (m *mockDaemon) CreateBead(_ context.Context, req beadsapi.CreateBeadRequest) (string, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	id := fmt.Sprintf("bd-chat-%d", len(m.beads)+1)
	m.beads[id] = &beadsapi.BeadDetail{
		ID:       id,
		Title:    req.Title,
		Type:     req.Type,
		Assignee: req.Assignee,
		Labels:   req.Labels,
	}
	return id, nil
}

func (m *mockDaemon) SpawnAgent(_ context.Context, agentName, project, taskID string) (string, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	id := fmt.Sprintf("bd-agent-%d", len(m.beads)+1)
	desc := ""
	if taskID != "" {
		desc = "Assigned to task: " + taskID
	}
	m.beads[id] = &beadsapi.BeadDetail{
		ID:          id,
		Title:       agentName,
		Type:        "agent",
		Description: desc,
		Fields:      map[string]string{"agent": agentName, "project": project, "mode": "crew", "role": "crew"},
	}
	return id, nil
}

func (m *mockDaemon) ListDecisionBeads(_ context.Context) ([]*beadsapi.BeadDetail, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	var result []*beadsapi.BeadDetail
	for _, b := range m.beads {
		if b.Type == "decision" {
			result = append(result, b)
		}
	}
	return result, nil
}

func (m *mockDaemon) ListAssignedTask(_ context.Context, agentName string) (*beadsapi.BeadDetail, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	for _, b := range m.beads {
		if b.Status == "in_progress" && b.Assignee == agentName {
			switch b.Type {
			case "agent", "decision", "project":
				continue
			}
			return b, nil
		}
	}
	return nil, nil
}

func (m *mockDaemon) ListProjectBeads(_ context.Context) (map[string]beadsapi.ProjectInfo, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	result := make(map[string]beadsapi.ProjectInfo)
	for _, b := range m.beads {
		if b.Type == "project" {
			result[b.Title] = beadsapi.ProjectInfo{Name: b.Title}
		}
	}
	return result, nil
}

func (m *mockDaemon) ListAgentBeads(_ context.Context) ([]beadsapi.AgentBead, error) {
	m.mu.Lock()
	defer m.mu.Unlock()
	var result []beadsapi.AgentBead
	for _, b := range m.beads {
		if b.Type == "agent" {
			result = append(result, beadsapi.AgentBead{
				ID:      b.ID,
				Project: b.Fields["project"],
				Mode:    "crew",
				Role:    b.Fields["role"],
			})
		}
	}
	return result, nil
}

func (m *mockDaemon) getClosed() []closeCall {
	m.mu.Lock()
	defer m.mu.Unlock()
	return append([]closeCall{}, m.closed...)
}

func (m *mockDaemon) getGetCalls() int {
	m.mu.Lock()
	defer m.mu.Unlock()
	return m.getCalls
}

// mockNotifier records calls to NotifyDecision, UpdateDecision, NotifyEscalation, and DismissDecision.
type mockNotifier struct {
	mu        sync.Mutex
	created   []BeadEvent
	updated   []updateCall
	escalated []BeadEvent
	dismissed []string
}

type updateCall struct {
	BeadID string
	Chosen string
}

func (m *mockNotifier) NotifyDecision(_ context.Context, bead BeadEvent) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.created = append(m.created, bead)
	return nil
}

func (m *mockNotifier) UpdateDecision(_ context.Context, beadID, chosen string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.updated = append(m.updated, updateCall{beadID, chosen})
	return nil
}

func (m *mockNotifier) NotifyEscalation(_ context.Context, bead BeadEvent) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.escalated = append(m.escalated, bead)
	return nil
}

func (m *mockNotifier) DismissDecision(_ context.Context, beadID string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.dismissed = append(m.dismissed, beadID)
	return nil
}

func (m *mockNotifier) PostReport(_ context.Context, _, _, _ string) error {
	return nil
}

func (m *mockNotifier) getCreated() []BeadEvent {
	m.mu.Lock()
	defer m.mu.Unlock()
	return append([]BeadEvent{}, m.created...)
}

func (m *mockNotifier) getUpdated() []updateCall {
	m.mu.Lock()
	defer m.mu.Unlock()
	return append([]updateCall{}, m.updated...)
}

func (m *mockNotifier) getEscalated() []BeadEvent {
	m.mu.Lock()
	defer m.mu.Unlock()
	return append([]BeadEvent{}, m.escalated...)
}

func (m *mockNotifier) getDismissed() []string {
	m.mu.Lock()
	defer m.mu.Unlock()
	return append([]string{}, m.dismissed...)
}

// marshalSSEBeadPayload wraps a BeadEvent in the kbeads SSE event format
// ({"bead": {...}}) for testing handleCreated/handleClosed which now accept
// raw SSE JSON data.
func marshalSSEBeadPayload(bead BeadEvent) []byte {
	data, _ := json.Marshal(map[string]any{"bead": bead})
	return data
}
